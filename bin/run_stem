#!/usr/local/bin/perl -w
#  File: bin/run_stem

#  This file is part of Stem.
#  Copyright (C) 1999, 2000, 2001 Stem Systems, Inc.

#  Stem is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.

#  Stem is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with Stem; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#  For a license to use the Stem under conditions other than those
#  described here, to purchase support for this software, or to purchase a
#  commercial warranty contract, please contact Stem Systems at:

#       Stem Systems, Inc.		781-643-7504
#  	79 Everett St.			info@stemsystems.com
#  	Arlington, MA 02474
#  	USA

$Data::Dumper::Indent = 1 ;
$Data::Dumper::Purity = 1 ;
$Data::Dumper::Useqq = 1 ;

$| = 1 ;

my @conf_args ;

# we set Stem's default environment before we load any Stem modules so
# they can use those values

BEGIN {
	my $env_text ;
	my $stem_lib_dir = '/usr/local/lib/stem' ;

# get the site env and home env files

	my @env_files = grep -r, "$stem_lib_dir/env",
				 ( $ENV{HOME} ||
				   $ENV{LOGDIR} ||
				   (getpwuid($>))[7] ) . '/.stem_env' ;

	foreach my $env_file ( @env_files ) {

# shut up a dumb warning
		use vars '*ARGVOUT' ;
		$env_text .= do { local( @ARGV, $/ ) = $env_file ; <> } ;
	}

# set the starting %env from the files

	%Stem::Vars::Env = $env_text =~ /^([^=]+)=(.+)$/mg if $env_text ;


# set the %Stem::Vars::Env from %ENV any %ENV name starting with STEM_
# is used. the STEM_ is deleted and the rest of the lower case name is
# used with the %ENV value

	/^STEM_(\w+)/ and $Stem::Vars::Env{ lc $1 } = $ENV{ $_ } for keys %ENV ;

# set %Stem::Vars::Env from 'name=value' command line args
# all other args are assumed to be conf file names.
# we do this after we process %ENV so the command line args can override
# any shell environment values

	while( @ARGV ) {

		my $arg = shift ;

		if ( $arg =~ /(\w+)=(.*)/ ) {

			$Stem::Vars::Env{ $1 } = $2 ;
			next ;
		}

		push @conf_args, $arg ;
	}

# set the default config search path. this will be changed by the install
# script.

	$Stem::Vars::Env{ 'conf_path' } ||= 'conf:.' ;

# set the trace levels

# 	$Stem::Vars::Env{ 'MainTraceStatus'    } ||= 1 ;
# 	$Stem::Vars::Env{ 'MainTraceError'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'ProcTraceStatus'    } ||= 1 ;
# 	$Stem::Vars::Env{ 'ProcTraceError'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'PortalTraceStatus'  } ||= 1 ;
# 	$Stem::Vars::Env{ 'PortalTraceError'   } ||= 1 ;
# 	$Stem::Vars::Env{ 'SockMsgTraceStatus' } ||= 1 ;
# 	$Stem::Vars::Env{ 'SockMsgTraceError'  } ||= 1 ;
# 	$Stem::Vars::Env{ 'ConfTraceStatus'    } ||= 1 ;
# 	$Stem::Vars::Env{ 'ConfTraceError'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'LogTraceStatus'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'LogTraceError'      } ||= 1 ;
# 	$Stem::Vars::Env{ 'CellTraceStatus'    } ||= 0 ;
# 	$Stem::Vars::Env{ 'CronTraceStatus'    } ||= 1 ;
# 	$Stem::Vars::Env{ 'CronTraceError'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'EventTraceStatus'   } ||= 0 ;
# 	$Stem::Vars::Env{ 'EventTraceError'    } ||= 0 ;
# 	$Stem::Vars::Env{ 'GatherTraceStatus'  } ||= 1 ;
# 	$Stem::Vars::Env{ 'GatherTraceError'   } ||= 1 ;
# 	$Stem::Vars::Env{ 'HubTraceStatus'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'HubTraceError'      } ||= 1 ;
# 	$Stem::Vars::Env{ 'TailTraceStatus'    } ||= 1 ;
# 	$Stem::Vars::Env{ 'TailTraceError'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'MsgTraceError'      } ||= 1 ;
# 	$Stem::Vars::Env{ 'MsgTraceStatus'     } ||= 1 ;
# 	$Stem::Vars::Env{ 'MsgTraceMsg'        } ||= 1 ;
# 	$Stem::Vars::Env{ 'SwitchTraceStatus'  } ||= 1 ;
# 	$Stem::Vars::Env{ 'SwitchTraceError'   } ||= 1 ;
# 	$Stem::Vars::Env{ 'AsynchIOTraceStatus'} ||= 1 ;
# 	$Stem::Vars::Env{ 'AsynchIOTraceError' } ||= 1 ;
# 	$Stem::Vars::Env{ 'TtyMsgTraceStatus'  } ||= 1 ;
# 	$Stem::Vars::Env{ 'TtyMsgTraceError'   } ||= 1 ;

}

# we load Stem after we process the command line args and %ENV so the
# modules can use those values

use Stem ;

use Stem::Trace 'log' => 'stem_status',
		'sub' => 'TraceStatus',
		'env' => 'MainTraceStatus' ;

my $prog_name = $0 ;

$prog_name =~ s|.+/|| ;

unless ( @conf_args ) {

	$prog_name eq 'run_stem' &&
			die "run_stem must be passed a stem config file" ;

	@conf_args = $prog_name ;
}

# always start with the site config file
# this defines site wide configuration settings that are internal
# to Stem

my $err = Stem::Conf::load_confs( 'site' ) ;

# ignore a missing site config

die $err if defined $err && $err !~ /Can't find config/ ;

$err = Stem::Conf::load_confs( @conf_args ) ;

TraceStatus "Stem startup" ;

TraceStatus $err if $err;

die $err if $err ;


$SIG{ 'INT' } = sub {
	TraceStatus "INT signal received" ;
	Stem::Event::end_loop()
} ;

Stem::Event::start_loop() ;

TraceStatus "Stem shutdown" ;

exit;

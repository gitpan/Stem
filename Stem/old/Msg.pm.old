# Copyright 2000 by Stem Systems, Inc. All rights reserved.

# If you have this software as part of the prototype release, you are
# not allowed to distribute any copies to anyone. This software is not
# to shown to anyone else without prior permission from Stem Systems.

use strict ;

package Stem::Msg ;

use Data::Dumper ;
use Carp ;

use Stem::Route qw( lookup_cell ) ;
use Stem::Debug ;

# lists of the address types and parts

my @addr_types = qw( to from reply ) ;
my @addr_parts = qw( hub cell target ) ;

# these are used to grab the types and parts from the method names in AUTOLOAD

my $type_regex = '(' . join( '|', @addr_types ) . ')' ;
my $part_regex = '(' . join( '|', @addr_parts ) . ')' ;


my $attr_spec = [

	{
		'name'		=> 'type',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'data',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'cmd',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'log',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'status',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'ack_req',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'in_portal',
		'help'		=> <<HELP,
HELP
	},

] ;

# get the plain (non-address) attributes for the AUTOLOAD and the
# message dumper

my %is_plain_attr = map { $_->{'name'}, 1 } @{$attr_spec} ;

# add the address types and parts to our attribute spec with callbacks
# for parsing

foreach my $type ( @addr_types ) {

	push @{$attr_spec}, {
		'name'		=> $type,
		'callback'	=> \&new_addr_type,
	} ;

	foreach my $part ( @addr_parts ) {

		push @{$attr_spec}, {
			'name'		=> "${type}_$part",
			'callback'	=> \&new_addr_type_part,
		} ;
	}
}

# print Dumper( $attr_spec ) ;


sub new {

	my( $class ) = shift ;

	my $self = Stem::Class::parse_args( $attr_spec, @_ ) ;
	return $self unless ref $self ;

#print "MSG: [$_] => [$args{$_}]\n" for sort keys %args ;

#print $self->dump( 'new MSG' ) ;

	return( $self ) ;
}

sub clone {

	my( $self ) = shift ;

my $msg = Stem::Msg->new( ( map { exists $self->{$_} ? ( $_, $self->{$_} ) : () }
			    @addr_types, keys %is_plain_attr ), @_ ) ;

#	print $self->dump( 'self' ) ;
#	print $msg->dump( 'clone' ) ;

	return $msg ;
}


sub new_addr_type {

	my( $self, $name, $value ) = @_ ;

	my $addr = parse_address( $value ) ;

	return $addr unless ref $addr ;

	$self->{$name} = $addr ;

	return ;
}

sub new_addr_type_part {

	my( $self, $name, $value ) = @_ ;

	if ( $name =~ /^${type_regex}_$part_regex$/o ) {

		$self->{$1}{$2} = $value ;

		return ;
	}

	return "unknown Stem::Msg type/part $name" ;
}

sub parse_address {

	return "missing address argument" unless @_ ;

	my $in_ref ;

	if ( @_ == 1 ) {

		unless ( ref $_[0] ) {

# old match
# /^(?:(\w*):)?(\w+)(?::(\w*))?$/

			$_[0] =~ m{^(?:((?:\w|::)*)([:/@-]))?(\w+)(?:\2(\w+))?$}
					 or return "bad string address" ;

			my $addr = { 'cell' => $3 } ;
			$addr->{ 'hub' } = $1 if length $1 ;
			$addr->{ 'target' } = $4 if length $4 ;

			return $addr ;
		}

		if ( ref $_[0] eq 'HASH' ) {

			$in_ref = $_[0] ;
		}
		elsif ( ref $_[0] eq 'ARRAY' ) {

			@{$_[0]} % 2 and
				return "odd number of hash values for address" ;
	
			$in_ref = { @{$_[0]} } ;
		}
		else {

			return "address arg is a bad ref type" ;
		}
	}
	else {

		@_ % 2 and return "odd number of hash values for address" ;

		$in_ref = { @_ } ;
	}

	my $addr = {

		map exists( $in_ref->{$_} ) ? ( $_, $in_ref->{$_} ) : (),
			@addr_parts
	} ;

	return $addr ;
}

sub address_string {

	my( $addr ) = @_ ;

	return $addr unless ref $addr ;

	return 'BAD ADDRESS' unless ref $addr eq 'HASH' ;

	return $addr->{'cell'} if keys %{$addr} == 1 ;

	return join ':', map { $_ || '' } @{$addr}{qw( hub cell target ) } ;
}


sub reply {

	my( $self ) = shift ;

#print "Reply [$self]\n" ;

#print $self->dump( 'reply self' ) ;

	my $to = $self->{'reply'} || $self->{'from'} ;
	my $from = $self->{'to'} ;

	my $reply_msg = Stem::Msg->new( 'to' => $to, 'from' => $from, @_ ) ;

#print $reply_msg->dump( 'new reply' ) ;

	return( $reply_msg ) ;
}

#####################
#####################
# add forward method which clones the old msg and just updates the to address.
#
# work needs to be done on from/origin parts and who sets them
#####################
#####################


sub error {

	my( $self, $err_text ) = @_ ;

#print "ERR [$self] [$err_text]\n" ;

	my $err_msg = $self->reply( 'type' => 'error',
				    'data' => \$err_text ) ;

#print $err_msg->dump( 'error' ) ;

	return( $err_msg ) ;
}


########################################
########################################
# from/origin address will be set if none by looking up the cell that
# is currently be called with a message. or use
# Stem::Event::current_object which is set before every event
# delivery.
########################################
########################################


my @msg_queue ;

sub dispatch {

	my( $self ) = @_ ;

#  $self->deliver() ;
#  return ;

#  	unless ( @msg_queue ) {

#  		Stem::Event::Plain->new( 'object' => __PACKAGE__,
#  					 'method' => 'deliver_msg_queue' ) ;
#  	}

	push @msg_queue, $self ;
}

sub process_queue {

	while( @msg_queue ) {

		my $msg = shift @msg_queue ;

		my $err = $msg->_deliver() ;

		if ( $err ) {

			my $err_text = "Undelivered:\n$err" ;

			print $msg->dump( "$err_text\nMsg" ) ;
#			print $err_text ;

#  			my $err_msg = $msg->error(
#  				"Hub $Stem::Vars::Hub_name: $err_text\n"
#  			) ;

#  			$err_msg->dispatch() ;

#####################################
# TODO: log bad messages
#####################################
		}
	}
}

sub _deliver {

	my( $self ) = @_ ;

#print $self->dump( "DELIVER" ) ;

	my $to = $self->{'to'} ;

	my $to_hub = $to->{'hub'} ;

	if ( $to_hub ) {

		if ( $to_hub eq $Stem::Vars::Hub_name ) {

			if ( my $cell = $self->_find_local_cell() ) {

				return $self->_deliver_to_cell( $cell ) ;
			}

			return $self->dump( "unknown cell in hub $to_hub" ) ;
		}

		return $self->_deliver_remote( $to_hub ) ;
	}

# no hub, see if we can deliver to a local cell 

	if( my $cell = $self->_find_local_cell() ) {

		return $self->_deliver_to_cell( $cell ) ;
	}

# not a local cell or named hub, send it to DEFAULT portal

	return unless $self->_deliver_remote( 'DEFAULT' ) ;

# see if this came in from a portal

	if ( $self->{'in_portal'} ) {

		return "outside message can't be delivered" ;
	}

	return "no DEFAULT portal" ;
}

sub _deliver_remote {

	my ( $self, $to_hub ) = @_ ;

	my $portal = Stem::Portal::find( $to_hub ) ;

	return "unknown Portal '$to_hub'" unless $portal ;

	if ( exists( $self->{'to'}{'hub'} ) && 
		     $self->{'to'}{'hub'} eq 'DEFAULT' ) {

		delete( $self->{'to'}{'hub'} ) ;
	}

	$portal->send( $self ) ;

	return ;
}

sub _find_local_cell {

	my ( $self ) = @_ ;

	my $cell_name	= $self->{'to'}{'cell'} ;
	my $target	=  $self->{'to'}{'target'} ;

	return lookup_cell( $cell_name, $target ) ||
	       lookup_cell( $cell_name ) ;
}

sub _deliver_to_cell {

	my ( $self, $cell ) = @_ ;

# set the method 

	my $method = ( $self->{'type'} eq 'cmd' ) ?
				"$self->{'cmd'}_cmd" :
				"$self->{'type'}_in" ;

# check if we can deliver there or to msg_in

	unless ( $cell->can( $method ) ) {

		return $self->dump( <<DUMP ) unless( $cell->can( 'msg_in' ) ) ;
missing message delivery methods '$method' and msg_in
DUMP

		$method = 'msg_in' ;
	}

#print "MSG to $cell $method\n" ;

	my $response = $cell->$method( $self ) ;

# if we get a response then return it in a message

	if ( $response && $self->{'type'} eq 'cmd' ) {

		my $reply_msg = $self->reply(
					'type' => 'response',
					'data' => \$response
		) ;

#print $reply_msg->dump( 'AUTO REPONSE' ) ;
		$reply_msg->dispatch() ;
	}

	if ( $self->{'ack_req'} ) {

		my $reply_msg = $self->reply( 'type' => 'msg_ack' ) ;

		$reply_msg->dispatch() ;
	}

	return ;
}


sub to_stream {

	my( $self ) = @_ ;

#print "BAD in_portal : ", Dumper($self), "\n" if $self->{'in_portal'} ;

	delete $self->{'in_portal'} ;

	my $msg_text = Dumper( $self ) ;

	substr( $msg_text, 0, 8, '' ) ;

#print "to stream [$msg_text]\n" ;

	$msg_text ;
}

sub from_stream {

	my( $msg_text ) = @_ ;

#print "eval msg [$msg_text]\n" ;

	return eval $msg_text ;
}

use vars qw( $AUTOLOAD ) ;

sub AUTOLOAD
{
	no strict 'refs';

	my ( $self ) = @_ ;

#print "AUTO: $AUTOLOAD $_[0] - [$_[1]]\n" ;

# FIX? make the individual address accessors set only if the value was undef.
# to force setting, use the type accessor (to, from, etc.)

	if ( $AUTOLOAD =~ /.*::${type_regex}_$part_regex$/o ) {
		my $type = $1;
		my $part = $2;

		*{$AUTOLOAD} = sub {

			$_[0]->{$type}{$part} = $_[1] if @_ > 1 ;
			return $_[0]->{$type}{$part} ;
		} ;

		goto &$AUTOLOAD ;
	}

	if ( $AUTOLOAD =~ /.*::${type_regex}$/o ) {
		my $type = $1;

		*{$AUTOLOAD} = sub {

			if ( @_ > 1 ) {

				my %args ;

				%args = ( ref $_[1] eq 'HASH' ) ?
					 %{$_[1]} : @_ ;

				$_[0]->{$type} = { map exists $args{$_} ?
						( $_, $args{$_} ) : (),
						    @addr_parts } ;
			}

			return wantarray ? %{$_[0]->{$type}} : $_[0]->{$type} ;
		} ;

		goto &$AUTOLOAD ;
	}

	if ( $AUTOLOAD =~ /.*::(\w+)/ && $is_plain_attr{ $1 } ) {
		my $attr_name = $1;
		*{$AUTOLOAD} = sub {

#print "$attr_name: $_[0] - [$_[1]]\n" ;

			$_[0]->{$attr_name} = $_[1] if @_ > 1 ;
			return $_[0]->{$attr_name}
		} ;

		goto &$AUTOLOAD ;
	}
	
# must be a bad method

	croak "Stem::Msg No such method: $AUTOLOAD";
}


sub DESTROY {

# no destroy code

}


# dump a message for debugging

sub dump {

	my( $self, $label, $deep ) = @_ ;

	my $dump = '' ;
	$label ||= 'UNKNOWN' ;

	my( $package, $line_num ) = (caller)[0,2] ;

#print "Line $line_num $package\n" ;

	$dump .= <<LABEL ;

Line $line_num $package
MSG $label = {
LABEL

	foreach my $type ( @addr_types ) {

		my $type_ref = $self->{$type} ;

		next unless $type_ref ;

		$dump .= <<TYPE ;
	$type	=> {
TYPE

		foreach my $part ( @addr_parts ) {

			my $part_val = $type_ref->{$part} ;

			next unless defined $part_val ;

			$dump .= <<PART ;
		$part	=> '$part_val',
PART
		}

		$dump .= <<TYPE ;
	},
TYPE

	}

	foreach my $attr ( sort keys %is_plain_attr ) {

		next unless exists $self->{$attr} ;

		my $tab = ( length $attr > 4 ) ? "" : "\t" ;

		my( $val_text, $q, $ret ) ; 

		if ( $deep || $attr eq 'data' ) {

			$val_text = Dumper( $self->{$attr} ) ;
			$val_text =~ s/^.+?=// ;
			$val_text =~ s/;\n?$// ;

			$q = '' ;
			$ret = "\n" ;
		}
		else {
			$val_text = $self->{$attr} ;
			$q = $val_text =~ /\D/ ? "'" : '' ;
			$ret = '' ;
		}

		$dump .= <<ATTR ;
	$attr$tab	=> $ret$q$val_text$q,
ATTR

	}

	$dump .= "}\n\n" ;

	return($dump) ;
}

1 ;

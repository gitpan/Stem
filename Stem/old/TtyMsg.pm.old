# Copyright 2000 by Stem Systems, Inc. All rights reserved.

# If you have this software as part of the prototype release, you are
# not allowed to distribute any copies to anyone. This software is not
# to shown to anyone else without prior permission from Stem Systems.

use strict ;

package Stem::TtyMsg ;

use Data::Dumper ;

use Stem::AsyncIO ;
use Stem::Vars ;


use vars qw( $tty_obj ) ;


Stem::Route::register_class( __PACKAGE__, 'tty' ) ;

#########################
# no attributes for now
#########################

my $attr_spec = [

	{
		'name'		=> 'prompt',
		'default'	=> "\nStem > ",
		'help'		=> <<HELP,
HELP
	},

] ;


sub new {

	my( $class ) = shift ;

	my $self = Stem::Class::parse_args( $attr_spec, @_ ) ;
	return $self unless ref $self ;

	my $aio = Stem::AsyncIO->new(

			'object'	=> $self,
			'read_fh'	=> \*STDIN,
			'write_fh'	=> \*STDOUT,
			'read_method'	=> 'stdin_read',
			'closed_method'	=> 'stdin_closed',
	) ;

	$self->{'aio'} = $aio ;

	$tty_obj = $self ;

	$self->write( "\nEnter 'help' for help\n\n" ) ;
	$self->prompt() ;

	return ;
}

sub stdin_read {

	my( $self, $line_ref ) = @_ ;

	my $line = ${$line_ref} ;

	chomp( $line ) ;

	if ( $line =~ /^\s*$/ ) {

		$self->prompt() ;
		return ;
	}

	if ( $line =~ /^quit\s*$/i ) {

		exit ;
	}

	if ( $line =~ /^\s*help\s*$/i ) {

		$self->help() ;
		$self->prompt() ;
		return ;
	}

	if ( my( $key, $val ) = $line =~ /^\s*(\w+)\s*=\s*(.+)$/ ) {

		$val =~ s/\s+$// ;

		$self->write( "Setting Environment '$key' to '$val'\n" ) ;
		$Env{ $key } = $val ;

		$self->prompt() ;

		return ;
	}

	unless ( $line =~ /^\s*(\S+)\s+(.*)$/ ) {

		$self->write( <<ERR ) ;
Tty commands must be in the form
Hub:Object Cmd

ERR
		$self->prompt() ;

		return ;
	}

	my $addr = Stem::Msg::parse_address( $1 ) ;

	unless( ref $addr ) {

		$self->write( <<ERR ) ;
Illegal address for Tty command
ERR
		$self->prompt() ;

		return ;
	}

	my( $cmd_name, $cmd_data ) = split( ' ', $2, 2 ) ;


#print "tty N[$hub_name] O[$cell_name] C[$cmd_name]\n" ;

	my $msg = Stem::Msg->new(
			'to'		=> $addr,
			'from_cell'	=> __PACKAGE__,
			'type'		=> 'cmd',
			'cmd'		=> $cmd_name,
			'data'		=> \$cmd_data,
	) ;

	$msg->dispatch() ;

	$self->prompt() ;

	return ;
}

sub data_in {

	goto &response_in ;
}

sub response_in {

	my( $self, $msg ) = @_ ;

	$self = $tty_obj unless ref $self ;

	my $data = $msg->data() ;

#print $msg->dump( 'TTY' ) ;

	$self->write( "\n\n" ) ;

	if ( ref $data eq 'SCALAR' ) {

		$self->write( ${$data} ) ;
	}
	elsif( ref $data ) {

		$self->write( Dumper( $data ) ) ;
	}
	else {

		$self->write( $data ) ;
	}

#print ::BUG "M [$data]\n" ;

	$self->prompt() ;
}

sub write {

	my( $self, $text ) = @_ ;

	$self = $tty_obj unless ref $self ;

	$self->{'aio'}->write( $text) ;
}


sub prompt {

	my( $self ) = @_ ;

	return unless $self->{'prompt'} ;

	$self->write( $self->{'prompt'} ) ;
}

sub help {

	my( $self ) = @_ ;

	$self->write( <<HELP ) ;

Stem::TtyMsg Help:

You can enter various commands to Stem here. 

If the line is of the form:

hub:cell:target cmd data_text

then a command message is created. The hub part is optional but then
the cell name must be prefixed with a :. The :target is also optional
but then the cell name doesn't need a trailing :.

The next token is the command name and the rest of the line is used as
the data of the message.

Examples:

:reg status

will send a 'status' command message to the 'reg' cell which is the Stem::Route class. A listing of all registered Cells will be returned and printed.

server:sw map a c d

That will send a 'map' command message to the Cell named 'sw' in the
Hub named 'server'. The data will be the string 'a c d'. That is used to change
the mapping of target 'a' to c, d in the Switch Cell in the chat demo.

If the line is of the form:

key=value

then the global command args hash %Stem::Vars::Env has that key
set to the value. This is used to change any command line argument
value at run time. This can be used to enable/disable log filters,
debug filters and any other internal operation that looks at the
%Stem::Vars::Env hash.

HELP

}

sub stdin_closed {

	my( $self ) = @_ ;

	*STDIN->clearerr() ;

	$self->write( "EOF (ignored)\n" ) ;

	$self->prompt() ;
}

1 ;

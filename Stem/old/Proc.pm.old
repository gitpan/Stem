# Copyright 2000 by Stem Systems, Inc. All rights reserved.

# If you have this software as part of the prototype release, you are
# not allowed to distribute any copies to anyone. This software is not
# to shown to anyone else without prior permission from Stem Systems.

use strict ;

package Stem::Proc ;

use Data::Dumper ;
use Socket ;
use Symbol ;
use Carp ;
use IO::Pty ;

use Stem::Route qw( :cell ) ;
use Stem::Debug ;

use base 'Stem::Cell' ;


my %pid_to_cell ;

my $attr_spec = [


###############
# if you pass in an optional object, then that will be the base for
# all the callback methods. the message and log options will not be
# done as they work only using the callbacks internal to Stem::Proc.
###############

	{
		'name'		=> 'reg_name',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'object',
		'type'		=> 'object',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'path',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'proc_args',
		'default'	=> [],
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'no_io',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'no_read',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'no_write',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'no_async',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'spawn',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'use_pty',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'use_stderr',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'read_method',
		'default'	=> 'proc_read_data',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'stderr_method',
		'default'	=> 'proc_stderr_data',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'exited_method',
		'default'	=> 'proc_exited',
		'help'		=> <<HELP,
HELP
	},

	{
		'name'		=> 'cell_info',
		'class'		=> 'Stem::Cell',
		'help'		=> <<HELP,
HELP
	},
] ;


sub new {

	my( $class ) = shift ;

	my $self = Stem::Class::parse_args( $attr_spec, @_ ) ;
	return $self unless ref $self ;

	$self->{ 'no_async' } ||= $self->{ 'no_io' } ;

	$self->{ 'use_stderr' } = 0 if $self->{ 'use_pty' } ;


	$self->cell_set_args(
			'path'		=> $self->{'path'},
			'proc_args'	=> $self->{'proc_args'},
			'spawn'		=> $self->{'spawn'},
	) ;

	return $self->cell_trigger() ;
}

sub triggered_cell {

	my( $self ) = @_ ;

	return "SockMsg: can't connect a server socket" if $self->{'server'} ;

	print "SockMsg triggered\n" ;

	return $self->connect() ;
}



sub spawn {

	my( $self, $proc_args_ref ) = @_ ;

	my $cell_info = $self->{'cell_info'} ;

	my $cell = $cell_info->clone() ;

	$self->cell_trigger() ;

	my $err = $cell->fork_proc( $proc_args_ref ) ;

	return $err if $err ;

	return $cell ;

	return $self ;
}

#print Dumper( $self ) ;

	if ( $self->{ 'spawn' } ) {

		$self->spawn() ;
	}


}

sub fork_proc {

	my( $self, $proc_args_ref ) = @_ ;

	unless( $self->{'no_io'} ) {

		$self->_parent_io() ;
	}

	$self->{'ppid'} = $$ ;	

	if ( my $pid = fork() ) {

# in parent

# must close the child fh in the parent so we will see a closed socket
# when the child exits

		unless( $self->{'no_io'} ) {

			close $self->{'child_fh'} ;
			close $self->{'child_err_fh'} if $self->{'use_stderr'} ;

			delete( $self->{'child_fh'} ) ;
			delete( $self->{'child_err_fh'} ) ;
		}

print "forked $pid\n" ;
		$self->{'pid'} = $pid ;	
		$pid_to_cell{ $pid } = $self ;

#print "FORK $self\n", Dumper $self ;

	}
	else {

# in child
		unless( $self->{'no_io'} ) {

			$self->_child_io() ;
		}

		if ( my $path = $self->{'path'} ) {

#print `pwd` ;

###############
###############
## add support for setting local(%ENV)
###############
###############

			my @exec_args = @{$self->{'proc_args'}} ;

#Debug Dumper $self ;

			if ( $proc_args_ref && ref $proc_args_ref eq 'ARRAY' ) {

				push @exec_args, @{$proc_args_ref} ;
			}

print "exec $path, @exec_args\n" ;

			exec $path, @exec_args ;
		}

		Debug "EXEC FAIL $!\n" ;
	}

# back in parent (unless no exec -- FIX THAT!! unless path is
# required) we could do a forked stem hub by execing stem with a new
# config which has a portal with STDIN/STDOUT as fh's

	unless ( $self->{'no_async'} ) {

		my $object = $self->{'object'} || $self ;

		$aio_args = {

			'object'	=> $object,
			'read_fh'	=> $self->{'parent_fh'},
			'write_fh'	=> $self->{'parent_fh'},
			'stderr_fh'	=> $self->{'parent_err_fh'},
			'read_method'	=> $self->{'read_method'},
			'stderr_method'	=> $self->{'stderr_method'},
			'closed_method'	=> $self->{'exited_method'},
		} ;

		$self->{'aio'} = $aio ;
	}

	return ;
}


sub _parent_io {

	my( $self ) = @_ ;

	my( $parent_fh, $child_fh ) ;


	if ( $self->{'use_pty'} ) {

		$parent_fh = IO::Pty->new() ;
		$child_fh = $parent_fh->slave() ;
	}
	else {

		$parent_fh = gensym ;
		$child_fh = gensym ;

		socketpair( $parent_fh, $child_fh,
				 AF_UNIX, SOCK_STREAM, PF_UNSPEC ) ||
					die "can't make socket pair $!" ;
	}

	bless $parent_fh, 'IO::Socket::INET' ;

	$self->{'parent_fh'} = $parent_fh ;

	$parent_fh->blocking( 0 ) ;

	$self->{'child_fh'} = $child_fh ;

	if ( $self->{'use_stderr'} ) {

		my $parent_err_fh = gensym ;
		my $child_err_fh = gensym ;

		socketpair( $parent_err_fh, $child_err_fh,
				 AF_UNIX, SOCK_STREAM, PF_UNSPEC ) ||
				die "can't make socket pair $!" ;

		$self->{'parent_err_fh'} = $parent_err_fh ;
		$self->{'child_err_fh'} = $child_err_fh ;
	}
}

sub _child_io {

	my( $self ) = @_ ;

#print "in child io\n" ;

	close $self->{'parent_fh'} ;
	close $self->{'parent_err_fh'} if $self->{'use_stderr'} ;

	my $child_fd = fileno( $self->{'child_fh'} ) ;

	open( \*STDIN,  "<&$child_fd" ) ||
				croak "dup open of STDIN failed $!" ;

	open( \*STDOUT, ">&$child_fd" ) ||
				croak "dup open of STDOUT failed $!" ;

	if ( $self->{'use_stderr'} ) {

		my $child_err_fd = fileno( $self->{'child_err_fh'} ) ;

		open( \*STDERR,  ">&$child_err_fd" ) ||
				croak "dup open of STDERR failed $!" ;

	}
	else {
		open( \*STDERR,  ">&$child_fd'}" ) ||
				croak "dup open of STDERR failed $!" ;
	}
}

sub clone_exited {

	my( $self, $target ) = @_ ;

	return unless $self->{ 'is_parent' } ;

	return unless $target ;

	my $clone = $self->{'clones'}{$target} ;

print "sock unreg $clone\n" ;

	my $err = Stem::Route::unregister_cell( $clone ) ;

print "unreg err $err\n" if $err ;

	delete ( $self->{'clones'}{$target} ) ;
	$self->{'id_obj'}->delete( $target ) ;
}


#	my $clone = $self->spawn( $data->{'piped_args'} ) ;

sub write {

	my( $self, $data ) = @_ ;

#print "PROC WRITE [$$data]\n" ;

	return if $self->{'no_async'} ;

	$self->{'aio'}->write( $data ) ;
}


sub read_fh {

#print "read fh	$_[0]->{'parent_fh'}\n" ;

	$_[0]->{'parent_fh'} ;
}

sub write_fh {

#print "write fh	$_[0]->{'parent_fh'}\n" ;

	$_[0]->{'parent_fh'} ;
}

sub stderr_fh {

	$_[0]->{'parent_err_fh'} ;
}




sub stderr_data {

}

sub proc_exited {

	my( $self ) = @_ ;

	my $msg = $self->{'exited_msg'} ;

#####################
## deal with process shutdown
#####################

print "CHILD EXITED\n" ;

	$self->{'aio'}->shut_down() ;
	delete $self->{'aio'} ;

	if ( $msg ) {

#print $msg->dump( 'proc' ) ;
		$msg->dispatch() ;
	}

########
# put log stuff here
########

}

sub async_closed {

	my( $self ) = @_ ;

	$self->shut_down() ;
}


sub sigchld_handler {


}


sub shut_down {

	my( $self ) = @_ ;

# kill the process

print "kill of proc $self->{'pid'}\n" ;

	kill 'SIGTERM', $self->{'pid'} ;

	return if $self->{'no_io'} ;

	if ( my $aio = $self->{'aio'} ) {

		$aio->shut_down() ;

		delete $self->{'aio'} ;

		return ;
	}

	close $self->{'parent_fh'} ;
	close $self->{'parent_err_fh'} if $self->{'use_stderr'} ;
}

1 ;

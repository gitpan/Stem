# Copyright 2000 by Stem Systems, Inc. All rights reserved.

# If you have this software as part of the prototype release, you are
# not allowed to distribute any copies to anyone. This software is not
# to shown to anyone else without prior permission from Stem Systems.


package Stem::Cell ;

use strict ;

use Data::Dumper ;

use Stem::Route qw( :cell ) ;
use Stem::AsyncIO ;
use Stem::Id ;
use Stem::Gather ;

my %class_to_attr_name ;

my $attr_spec = [

	{
		'name'		=> 'cloneable',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
The parent Cell will be cloned upon triggering
HELP
	},
	{
		'name'		=> 'data_addr',
		'type'		=> 'address',
		'help'		=> <<HELP,
Cell address to send any data read in. If not set here it must come
from a message.
HELP
	},
	{
		'name'		=> 'status_addr',
		'type'		=> 'address',
		'help'		=> <<HELP,
Cell address to send Cell status to
HELP
	},
	{
		'name'		=> 'send_data_on_close',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
Buffer all read data and only send it when the I/O is closed
HELP
	},
	{
		'name'		=> 'no_io',
		'type'		=> 'boolean',
		'help'		=> <<HELP,
Don't do any I/O for the Cell. Either there is none or the owner Cell must
do its own I/O
HELP
	},
	{
		'name'		=> 'pipe_addr',
		'type'		=> 'address',
		'help'		=> <<HELP,
Cell address to open a pipe to
HELP
	},
	{
		'name'		=> 'pipe_args',
		'help'		=> <<HELP,
HELP
	},
	{
		'name'		=> 'id_size',
		'default'	=> 3,
		'help'		=> <<HELP,
Size of unique ID space for clones. Range is 26**N
HELP
	},
	{
		'name'		=> 'trigger_method',
		'default'	=> 'triggered_cell',
		'help'		=> <<HELP,
Method to callback in owner object when cell is triggered
HELP
	},

# the below attributes are not permanent yet
# unused so far.
	{
		'name'		=> 'shut_down_method',
		'default'	=> 'shut_down_cell',
		'help'		=> <<HELP,
Method to callback in owner object when cell is shutdown
HELP
	},


	{
		'name'		=> 'activated_method',
		'default'	=> 'activate_cell',
		'help'		=> <<HELP,
HELP
	},
] ;


sub new {

	my( $class ) = shift ;

	my $self = Stem::Class::parse_args( $attr_spec, @_ ) ;
	return $self unless ref $self ;

	return( $self ) ;
}

# this is only called in Stem::Conf for this class.
# it initialized the cell info object inside its owner object.

sub cell_init {

	my( $self, $owner_obj, $cell_name, $cell_info_attr ) = @_ ;

# the $owner_obj is the cell that owns this Stem::Cell object

	$self->{'owner_obj'} = $owner_obj ;
	$self->{'cell_name'} = $cell_name ;
	$self->{'from_addr'} = $cell_name ;
	$self->{'cell_info_attr'} = $cell_info_attr ;

# save the attribute name that the owner class uses for the cell info.
# this is how a cell info object can be found given an owner cell object.
# also keep this name in the info itself

	$class_to_attr_name{ ref $owner_obj } ||= $cell_info_attr ;

	if ( $self->{'cloneable'} ) {

		$self->{'id_obj'} = Stem::Id->new(
					'size'	=> $self->{'id_size'} ) ;
		$self->{'is_parent'} = 1 ;
		$self->{'target'} = '' ;
	}
}

sub _get_cell_info {

	my ( $self ) = @_ ;

	my $class = ref $self ;

	return $self if $class eq __PACKAGE__ ;

	return	$self->{ $class_to_attr_name{ $class } } ;
}

sub cell_trigger {

	my ( $self ) = @_ ;

	my $self_info = $self->_get_cell_info() ;

	return if $self_info->{'triggered'} ;

# clone this cell and its info if needed
# $cell will either be $self or a clone of $self

	my $cell = $self_info->_clone() ;

	my $cell_info = $cell->_get_cell_info() ;

	$cell_info->{'triggered'} = 1 ;

	unless( $cell_info->{'no_io'} ) {

		my @gather_keys = 'aio_args' ;

		push @gather_keys, 'data_addr'
				unless $cell_info->{'data_addr'} ;

		my $gather = Stem::Gather->new(
				'object'	=> $cell_info,
				'keys'		=> \@gather_keys,
				'gathered_method' => '_cell_activated',
		) ;

		return $gather unless ref $gather ;

		$cell_info->{'gather'} = $gather ;

		my $err = $gather->gathered( keys %{$cell_info->{'args'}} ) ;

		return $err if $err ;
	}

# print $cell_info->_dump() ;

	$cell_info->_cell_pipe() ;

	return $cell_info ;
}

sub cell_trigger_cmd {

	my ( $self, $msg ) = @_ ;

	if ( my $data = $msg->data() ) {

		if ( ref $data eq 'HASH' ) {

			$self->cell_set_args( %{$data} ) ;
		}
	}

	my $cell_info = $self->cell_trigger() ;

	return $cell_info unless ref $cell_info ;

# do the callback into the (possibly cloned) cell

	return $cell_info->_callback( 'trigger_method' ) ;
}

sub cell_shut_down {

	my( $self ) = @_ ;

#print "CELL shut:\t", caller($_), "\n" for 1 .. 4;

	my $cell_info = $self->_get_cell_info() ;

	return unless $cell_info->{'active'} ;

	if ( my $aio = delete $cell_info->{'aio'} ) {

		$aio->shut_down() ;
	}

	if ( my $gather = delete $cell_info->{'gather'} ) {

		$gather->shut_down() ;
	}

	if ( $cell_info->{'piped'} ) {

print "pipe closing\n" ;

		my $data_addr = $cell_info->{'args'}{'data_addr'} ||
				$cell_info->{'data_addr'} ;

		my $close_msg = Stem::Msg->new(
			'type'		=> 'cmd',
			'cmd'		=> 'cell_pipe_close',
			'to'		=> $data_addr,
			'from'		=> $self->{'from_addr'},
		) ;

		$close_msg->dispatch() ;
	}

	$cell_info->_clone_delete() ;

	delete $cell_info->{'args'} ;
 	delete $cell_info->{'data_addr'} ;

	$cell_info->{'active'} = 0 ;
	$cell_info->{'triggered'} = 0 ;

print "cell shut down done\n" ;

	return ;
}

sub cell_cloneable {

	my( $self ) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	return $cell_info->{'cloneable'} ;
}

sub cell_set_args {

	my( $self, %args ) = @_ ;

#print "SET args: ", Dumper \%args ;

	my $cell_info = $self->_get_cell_info() ;

	@{$cell_info->{'args'}}{ keys %args } = values %args ;

	if( my $gather = $cell_info->{'gather'} ) {

		$gather->gathered( keys %args ) ;
	}
}

sub cell_get_args {

	my( $self, @arg_keys ) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	return( @{$cell_info->{'args'}}{@arg_keys } ) ;
}

sub _cell_activated {

	my ( $self ) = @_ ;

	my $aio_args = $self->{'args'}{'aio_args'} ;

	ref $aio_args eq 'ARRAY' or return <<ERR ;
aio_args is not an ARRAY ref
ERR
	my $data_addr = $self->{'args'}{'data_addr'} || $self->{'data_addr'} ;

	my $aio = Stem::AsyncIO->new(

		'object'		=> $self->{'owner_obj'},
		'data_addr'		=> $data_addr,
		'from_addr'		=> $self->{'from_addr'},
		'send_data_on_close'	=> $self->{'send_data_on_close'},
		@{$aio_args},
	) ;

	return $aio unless ref $aio ;

	$self->{'aio'} = $aio ;

#print "activated\n" ;
	$self->{'active'} = 1 ;

	return ;
}


sub status_cmd {

	my( $self ) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	my $info = $cell_info->{'args'}{'info'} || '' ;

	$info =~ s/^/\t\t/mg ;
 
	my $class = ref $cell_info->{'owner_obj'} ;

	my $data_addr = Stem::Msg::address_string( 
				$cell_info->{'data_addr'} ||
				$cell_info->{'args'}{'data_addr'} ||
				'[NONE]' ) ;

	my $active = ( $cell_info->{'active'} ) ? 'Active' : 'Inactive' ;

	return <<STATUS ;
Cell Status for:
Class:		$class
Addr:		$cell_info->{'from_addr'}
Status:		$active
Data Addr:	$data_addr
Info:$info
STATUS

}

sub data_in {

	my( $self, $msg ) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	if ( $cell_info->{'is_parent'} ) {
		print "parent cell $cell_info->{'from_addr'} ignoring msg\n" ;
		return ;
	}

	unless( $cell_info->{'active'} ) {

		print "cell not active. msg ignored\n" ;
		return ;
	}

	$cell_info->{'aio'}->write( $msg->data() ) ;
}


# $cell_info is the Stem::Cell object of the parent cell. the name is
# not self as it is differentiated from $clone_info.


#####################
#####################
# add check of max clone count
#####################
#####################

sub _clone {

	my( $cell_info ) = @_ ;

	my $owner_obj = $cell_info->{'owner_obj'} ;

	return $owner_obj unless $cell_info->{'cloneable'} ;

# copy the object

	my $clone = bless { %{$owner_obj} }, ref $owner_obj ;

# get a new target id and the cell name

	my $target = $cell_info->{'id_obj'}->next() ;

	my $cell_name = $cell_info->{'cell_name'} ;

# keep track of the clone in the parent and register it

	$cell_info->{'clones'}{$target} = $clone ;

	register_cell( $clone, $cell_name, $target ) ;

# the parent loses its args to the clone. parent cells never do real work

	my $args = delete $cell_info->{'args'} ;

# create the clone info and save it in the cloned object

	my $cell_info_attr = $cell_info->{'cell_info_attr'} ;

	my $clone_info = bless {

		'owner_obj'		=> $clone,
		'parent_obj'		=> $owner_obj,
		'cell_name'		=> $cell_name,
		'target'		=> $target,
		'from_addr'		=> ":$cell_name:$target",
		'data_addr'		=> $cell_info->{'data_addr'},
		'args'			=> $args,
		'cell_info_attr'	=> $cell_info_attr,
	} ;

# save the new clone info into the clone itself ;

	$clone->{$cell_info_attr} = $clone_info ;

	return $clone ;
}

sub _clone_delete {

	my ( $self ) = @_ ;

	my $parent_obj		= $self->{'parent_obj'} ;

	return unless $parent_obj ;

	my $owner_obj		= $self->{'owner_obj'} ;

	my $cell_info_attr	= $self->{'cell_info_attr'} ;

# break all circular links
# delete the refs to the parent and parent objects in the cell info
# and the owner object ref to this cell info

	delete @{$self}{ qw( owner_obj parent_obj ) } ;
	delete $owner_obj->{$cell_info_attr} ;

	delete $self->{'args'} ;

# clean up the parent clones hash and the registry

	my $parent_info		= $parent_obj->{$cell_info_attr} ;
	my $target		= $self->{'target'} ;

	delete $parent_info->{'clones'}{$target} ;
	$parent_info->{'id_obj'}->delete( $target ) ;

	my $err = unregister_cell( $owner_obj ) ;
}

sub _callback {

	my ( $self, $method_name, @data ) = @_ ;

	my $method = $self->{$method_name} ;

	my $owner_obj = $self->{'owner_obj'} ;

	if ( $owner_obj->can( $method ) ) {

		return $owner_obj->$method( @data ) ;
	}

print "can't call $method in $owner_obj\n" ;

	return ;
}


sub _cell_pipe {

	my( $self ) = @_ ;

	if ( $self->{'args'}{'pipe_open'} ) {

		$self->{'piped'} = 1 ;

# return the connection handshake

		my $addr_msg = Stem::Msg->new(
			'type'		=> 'cmd',
			'cmd'		=> 'cell_pipe_addr',
			'to'		=> $self->{'args'}{'data_addr'},
			'from'		=> $self->{'from_addr'},
		) ;

		print $addr_msg->dump( 'addr' ) ;
		$addr_msg->dispatch() ;

		return ;
	}

	my $pipe_addr = $self->{'args'}{'pipe_addr'} || $self->{'pipe_addr'} ;

	return unless $pipe_addr ;

	$self->{'piped'} = 1 ;

print "PIPE ADDR $pipe_addr\n" ;

# start the pipe connection handshake

	my $open_msg = Stem::Msg->new(
			'type'		=> 'cmd',
			'cmd'		=> 'cell_trigger',
			'to'		=> $pipe_addr,
			'from'		=> $self->{'from_addr'},
			'data'		=> {
				'pipe_args' => $self->{'args'}{'pipe_args'},
				'pipe_open' => 1,
				'data_addr' => $self->{'from_addr'},
			},
	) ;

	print $open_msg->dump( 'open' ) ;
	$open_msg->dispatch() ;

#print "\nPIPE $self\n", Dumper $self ;

}

# this command sub sets the data address at the end of a pipe handshake

sub cell_pipe_addr_cmd {

	my( $self, $msg ) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	$cell_info->{'data_addr'} = $msg->from() ;

	$cell_info->{'gather'}->gathered( 'data_addr' ) ;

	return ;
}

sub cell_pipe_close_cmd {

	my( $self, $msg ) = @_ ;

print "pipe closed cmd\n" ;

	$self->cell_shut_down() ;

	return ;
}


sub _dump {

	my ( $self ) = @_ ;

	my $dump ;

	foreach my $key ( sort keys %{$self} ) {

		my $val = $self->{$key} || '';

		if ( $key eq 'args' ) {

			$dump .= "\targs = {\n" ;

			foreach my $arg ( sort keys %{$val} ) {

				my $arg_val = $val->{$arg} || '';

				$dump .= "\t\t$arg = '$arg_val'\n" ;
			}

			$dump .= "\t}\n" ;

			next ;
		}

		$dump .= "\t$key = '$val'\n" ;
	}

	$dump .= "\n\n" ;

	return $dump ;
}

sub dump_cmd {

	my ($self) = @_ ;

	my $cell_info = $self->_get_cell_info() ;

	return $cell_info->_dump() . Dumper $cell_info ;
}

1 ;

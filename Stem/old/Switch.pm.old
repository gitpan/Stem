# Copyright 2000 by Stem Systems, Inc. All rights reserved.

# If you have this software as part of the prototype release, you are
# not allowed to distribute any copies to anyone. This software is not
# to shown to anyone else without prior permission from Stem Systems.

use strict ;

package Stem::Switch ;

=head1 Stem::switch

Stem::Switch has several functions:

 new 
 msg_in 
 data_in 
 map_cmd 
 info_cmd 
 status_cmd 

=cut

my $this_package = __PACKAGE__ ;

my $attr_spec = [

	{
		'name'		=> 'reg_name',
		'required'	=> 1,
		'help'		=> <<HELP,
Required field.
This is a unique name used to register this instance of a Switch.
HELP
	},

	{
		'name'		=> 'in_map',
		'default'	=> {},
		'help'		=> <<HELP,
This field contains the incoming address map.
Any message coming in to one of these addresses will be resent out
to every address in out_map.
HELP
	},

	{
		'name'		=> 'out_map',
		'default'	=> {},
		'help'		=> <<HELP,
This contains the outgoing addresses for this Switch.
HELP
	},

] ;

=head2 new

new creates a new Stem::Switch object, parsing $attr_spec and any arguments
passed to it.

It returns the new object.

=cut

sub new {

	my( $class ) = shift ;

	my $self = Stem::Class::parse_args( $attr_spec, @_ ) ;
	return $self unless ref $self ;


#############################
#############################
# convert out_map's value to real messages now.
# add support to change the out maps at runtime
#############################
#############################

	return( $self ) ;
}

use Data::Dumper ;

sub msg_in {

	my( $self, $msg ) = @_ ;

print $msg->dump( "unknown switch message" ) ;

}

sub data_in {

	my( $self, $msg ) = @_ ;

	my $in_target = $msg->to_target() ;

	my $in_map = $self->{'in_map'}{$in_target} ;

	return unless $in_map ;

	my @out_keys = ref $in_map ? @{$in_map} : ($in_map) ;

# loop over all the output keys for this in_map entry

	foreach my $out_key ( @out_keys ) {

		my $out_addr = $self->{'out_map'}{$out_key} ;

		next unless $out_addr ;

		my @out_addrs = ref $out_addr ? @{$out_addr} : ($out_addr) ;

# loop over all the output address for this out_map entry

		foreach my $out_addr ( @out_addrs ) {

print Stem::Msg::address_string( $out_addr ) . "\n" ;

# now we clone the message with the new address

			my $switched_msg = $msg->clone(

				'to'	=>	$out_addr,
			) ;

# print $switched_msg->dump('SWITCH out msg') ;

			$switched_msg->dispatch() ;
		}
	}
}


sub map_cmd {

	my( $self, $msg ) = @_ ;

	my @tokens = split( ' ', ${$msg->data()} ) ;

	my $target = shift @tokens ;

	$self->{'in_map'}{$target} = \@tokens ;

	return ;
}

sub out_map_cmd {

	my( $self, $msg ) = @_ ;

	my @tokens = split( ' ', ${$msg->data()} ) ;

	my $key = shift @tokens ;

	$self->{'out_map'}{$key} = \@tokens ;

	return ;
}
	

sub info_cmd {

	my( $self, $msg ) = @_ ;

	return <<INFO ;

Info Response
Class: $this_package
Ref: $self

This cell is a message multiplex or switch. Any message addressed to a
target in the cell, can be resent to any subset of the output map
addresses.

INFO

}


sub status_cmd {

	my( $self, $msg ) = @_ ;

	my( $status_text ) ;

	$status_text = <<TEXT ;

Status of switch: $self->{'reg_name'}

In Map:

TEXT

	foreach my $target ( sort keys %{$self->{'in_map'}} ) {

		my $targets_ref = $self->{'in_map'}{$target} ;
		my @targets = ref $targets_ref ?
				@{$targets_ref} : ($targets_ref) ;

		$status_text .= "\t$target -> @targets\n" ;
	}

	my $out_ref = $self->{'out_map'} ;

	$status_text .= "\nOut Map:\n\n" ;

	foreach my $key ( sort keys %{$out_ref} ) {

		my $out_addr = $out_ref->{$key} ;
		my @out_addrs = ref $out_addr ? @{$out_addr} : ($out_addr) ;

		$status_text .= "\t$key -> " .
				join( ' ', map
				Stem::Msg::address_string( $_ ), @out_addrs ) .
				"\n" ;
	}

	return $status_text ;
}

1 ;
